/**\n * Integration Tests for API Endpoints\n * \n * Tests real API endpoints with actual database connections,\n * Redis caching, and service-to-service communication.\n */\n\nimport { jest, describe, it, expect, beforeAll, afterAll, beforeEach, afterEach } from '@jest/globals';\nimport request from 'supertest';\nimport { Client as PgClient } from 'pg';\nimport Redis from 'ioredis';\nimport { TestContainerManager } from '../utils/test-container-manager';\nimport { TestDataFactory } from '../utils/test-data-factory';\n\ndescribe('API Endpoints Integration Tests', () => {\n  let containerManager: TestContainerManager;\n  let dbClient: PgClient;\n  let redisClient: Redis;\n  let testDataFactory: TestDataFactory;\n  \n  // Service endpoints\n  let phoneGatewayApp: any;\n  let realtimeProcessorApp: any;\n  let userManagementApp: any;\n  let conversationEngineApp: any;\n  \n  beforeAll(async () => {\n    console.log('🐳 Starting test containers...');\n    \n    // Start test infrastructure containers\n    containerManager = new TestContainerManager();\n    await containerManager.startAll();\n    \n    // Setup database connection\n    dbClient = new PgClient({\n      host: 'localhost',\n      port: 5433,\n      database: 'ai_ninja_test',\n      user: 'test_user',\n      password: 'test_password'\n    });\n    await dbClient.connect();\n    \n    // Setup Redis connection\n    redisClient = new Redis({\n      host: 'localhost',\n      port: 6380,\n      db: 1 // Use test database\n    });\n    \n    // Initialize test data factory\n    testDataFactory = new TestDataFactory(dbClient, redisClient);\n    \n    // Setup test database schema\n    await testDataFactory.setupSchema();\n    \n    // Start service applications\n    const phoneGatewayModule = await import('../../services/phone-gateway/src/server');\n    phoneGatewayApp = phoneGatewayModule.default || phoneGatewayModule.app;\n    \n    const realtimeModule = await import('../../services/realtime-processor/src/server');\n    realtimeProcessorApp = realtimeModule.default || realtimeModule.app;\n    \n    const userMgmtModule = await import('../../services/user-management/src/server');\n    userManagementApp = userMgmtModule.default || userMgmtModule.app;\n    \n    console.log('✅ Test infrastructure ready');\n  }, 60000);\n  \n  afterAll(async () => {\n    console.log('🧹 Cleaning up test infrastructure...');\n    \n    if (dbClient) await dbClient.end();\n    if (redisClient) redisClient.disconnect();\n    if (containerManager) await containerManager.stopAll();\n    \n    console.log('✅ Cleanup complete');\n  }, 30000);\n  \n  beforeEach(async () => {\n    // Clear test data before each test\n    await testDataFactory.clearAll();\n    await redisClient.flushdb();\n  });\n  \n  describe('Phone Gateway API', () => {\n    describe('POST /webhook/incoming-call', () => {\n      it('should handle incoming call and create database record', async () => {\n        const user = await testDataFactory.createUser({\n          phone: '+1234567890',\n          name: 'Test User'\n        });\n        \n        const incomingCallPayload = {\n          eventType: 'Microsoft.Communication.CallConnected',\n          data: {\n            callLegId: 'test-call-integration',\n            from: { phoneNumber: '+0987654321' },\n            to: { phoneNumber: user.phone },\n            callConnectionId: 'test-connection-integration'\n          }\n        };\n        \n        const response = await request(phoneGatewayApp)\n          .post('/webhook/incoming-call')\n          .send(incomingCallPayload)\n          .expect(200);\n        \n        expect(response.body.success).toBe(true);\n        \n        // Verify database record was created\n        const callRecords = await dbClient.query(\n          'SELECT * FROM call_records WHERE azure_call_id = $1',\n          ['test-call-integration']\n        );\n        \n        expect(callRecords.rows).toHaveLength(1);\n        expect(callRecords.rows[0].user_id).toBe(user.id);\n        expect(callRecords.rows[0].caller_phone).toBe('+0987654321');\n        expect(callRecords.rows[0].call_status).toBe('active');\n      });\n      \n      it('should check whitelist and route accordingly', async () => {\n        const user = await testDataFactory.createUser();\n        const whitelistedContact = await testDataFactory.createWhitelistEntry({\n          user_id: user.id,\n          contact_phone: '+1111111111',\n          is_active: true\n        });\n        \n        const whitelistedCallPayload = {\n          eventType: 'Microsoft.Communication.CallConnected',\n          data: {\n            callLegId: 'whitelist-test',\n            from: { phoneNumber: whitelistedContact.contact_phone },\n            to: { phoneNumber: user.phone },\n            callConnectionId: 'whitelist-connection'\n          }\n        };\n        \n        const response = await request(phoneGatewayApp)\n          .post('/webhook/incoming-call')\n          .send(whitelistedCallPayload)\n          .expect(200);\n        \n        expect(response.body.action).toBe('transferred');\n        \n        // Verify call was marked as transferred\n        const callRecord = await dbClient.query(\n          'SELECT * FROM call_records WHERE azure_call_id = $1',\n          ['whitelist-test']\n        );\n        \n        expect(callRecord.rows[0].call_type).toBe('whitelisted');\n      });\n      \n      it('should handle spam calls with AI processing', async () => {\n        const user = await testDataFactory.createUser();\n        \n        const spamCallPayload = {\n          eventType: 'Microsoft.Communication.CallConnected',\n          data: {\n            callLegId: 'spam-test',\n            from: { phoneNumber: '+5555555555' },\n            to: { phoneNumber: user.phone },\n            callConnectionId: 'spam-connection'\n          }\n        };\n        \n        const response = await request(phoneGatewayApp)\n          .post('/webhook/incoming-call')\n          .send(spamCallPayload)\n          .expect(200);\n        \n        expect(response.body.action).toBe('ai_processing');\n        \n        // Verify call was routed to AI\n        const callRecord = await dbClient.query(\n          'SELECT * FROM call_records WHERE azure_call_id = $1',\n          ['spam-test']\n        );\n        \n        expect(callRecord.rows[0].call_type).toBe('spam_suspected');\n      });\n    });\n    \n    describe('GET /calls/:callId/status', () => {\n      it('should return call status from database', async () => {\n        const user = await testDataFactory.createUser();\n        const callRecord = await testDataFactory.createCallRecord({\n          user_id: user.id,\n          azure_call_id: 'status-test-call',\n          call_status: 'active'\n        });\n        \n        const response = await request(phoneGatewayApp)\n          .get('/calls/status-test-call/status')\n          .expect(200);\n        \n        expect(response.body.call).toMatchObject({\n          id: callRecord.id,\n          status: 'active',\n          userId: user.id\n        });\n      });\n      \n      it('should return 404 for non-existent call', async () => {\n        await request(phoneGatewayApp)\n          .get('/calls/non-existent-call/status')\n          .expect(404);\n      });\n    });\n  });\n  \n  describe('User Management API', () => {\n    describe('POST /users', () => {\n      it('should create user with database persistence', async () => {\n        const userData = {\n          phone: '+1234567890',\n          name: 'Integration Test User',\n          personality: 'polite'\n        };\n        \n        const response = await request(userManagementApp)\n          .post('/users')\n          .send(userData)\n          .expect(201);\n        \n        expect(response.body.user).toMatchObject(userData);\n        \n        // Verify user was created in database\n        const dbUser = await dbClient.query(\n          'SELECT * FROM users WHERE phone_number = $1',\n          [userData.phone]\n        );\n        \n        expect(dbUser.rows).toHaveLength(1);\n        expect(dbUser.rows[0].name).toBe(userData.name);\n      });\n      \n      it('should handle duplicate phone number', async () => {\n        const existingUser = await testDataFactory.createUser({\n          phone: '+1111111111'\n        });\n        \n        const duplicateUserData = {\n          phone: existingUser.phone,\n          name: 'Duplicate User'\n        };\n        \n        const response = await request(userManagementApp)\n          .post('/users')\n          .send(duplicateUserData)\n          .expect(409);\n        \n        expect(response.body.error).toContain('already exists');\n      });\n    });\n    \n    describe('GET /users/:id', () => {\n      it('should return user with cached data', async () => {\n        const user = await testDataFactory.createUser();\n        \n        // First request should hit database\n        const response1 = await request(userManagementApp)\n          .get(`/users/${user.id}`)\n          .expect(200);\n        \n        expect(response1.body.user.id).toBe(user.id);\n        \n        // Verify data was cached in Redis\n        const cachedUser = await redisClient.get(`user:${user.id}`);\n        expect(cachedUser).toBeTruthy();\n        \n        // Second request should hit cache (verify with performance)\n        const start = performance.now();\n        const response2 = await request(userManagementApp)\n          .get(`/users/${user.id}`)\n          .expect(200);\n        const duration = performance.now() - start;\n        \n        expect(response2.body.user.id).toBe(user.id);\n        expect(duration).toBeLessThan(50); // Should be fast from cache\n      });\n    });\n    \n    describe('PUT /users/:id', () => {\n      it('should update user and invalidate cache', async () => {\n        const user = await testDataFactory.createUser();\n        \n        // Cache user data\n        await request(userManagementApp)\n          .get(`/users/${user.id}`)\n          .expect(200);\n        \n        const updateData = {\n          name: 'Updated Name',\n          personality: 'direct'\n        };\n        \n        const response = await request(userManagementApp)\n          .put(`/users/${user.id}`)\n          .send(updateData)\n          .expect(200);\n        \n        expect(response.body.user.name).toBe(updateData.name);\n        \n        // Verify cache was invalidated\n        const cachedUser = await redisClient.get(`user:${user.id}`);\n        expect(cachedUser).toBeFalsy();\n        \n        // Verify database was updated\n        const dbUser = await dbClient.query(\n          'SELECT * FROM users WHERE id = $1',\n          [user.id]\n        );\n        \n        expect(dbUser.rows[0].name).toBe(updateData.name);\n        expect(dbUser.rows[0].personality).toBe(updateData.personality);\n      });\n    });\n  });\n  \n  describe('Whitelist Management API', () => {\n    describe('POST /whitelist', () => {\n      it('should add contact to whitelist with caching', async () => {\n        const user = await testDataFactory.createUser();\n        \n        const whitelistData = {\n          userId: user.id,\n          contactPhone: '+9999999999',\n          contactName: 'Important Contact'\n        };\n        \n        const response = await request(userManagementApp)\n          .post('/whitelist')\n          .send(whitelistData)\n          .expect(201);\n        \n        expect(response.body.contact.contactPhone).toBe(whitelistData.contactPhone);\n        \n        // Verify database record\n        const dbContact = await dbClient.query(\n          'SELECT * FROM smart_whitelists WHERE user_id = $1 AND contact_phone = $2',\n          [user.id, whitelistData.contactPhone]\n        );\n        \n        expect(dbContact.rows).toHaveLength(1);\n        expect(dbContact.rows[0].contact_name).toBe(whitelistData.contactName);\n        \n        // Verify cache was updated\n        const cachedWhitelist = await redisClient.get(`whitelist:${user.id}`);\n        expect(cachedWhitelist).toBeTruthy();\n        \n        const whitelistData_parsed = JSON.parse(cachedWhitelist!);\n        expect(whitelistData_parsed).toContainEqual(\n          expect.objectContaining({\n            contact_phone: whitelistData.contactPhone\n          })\n        );\n      });\n    });\n    \n    describe('GET /whitelist/check/:userId/:phone', () => {\n      it('should check whitelist status efficiently', async () => {\n        const user = await testDataFactory.createUser();\n        const whitelistEntry = await testDataFactory.createWhitelistEntry({\n          user_id: user.id,\n          contact_phone: '+8888888888'\n        });\n        \n        const response = await request(userManagementApp)\n          .get(`/whitelist/check/${user.id}/${encodeURIComponent('+8888888888')}`)\n          .expect(200);\n        \n        expect(response.body.isWhitelisted).toBe(true);\n        expect(response.body.contact.id).toBe(whitelistEntry.id);\n        \n        // Test non-whitelisted number\n        const response2 = await request(userManagementApp)\n          .get(`/whitelist/check/${user.id}/${encodeURIComponent('+1111111111')}`)\n          .expect(200);\n        \n        expect(response2.body.isWhitelisted).toBe(false);\n      });\n    });\n  });\n  \n  describe('Service Communication', () => {\n    it('should handle phone-gateway to realtime-processor communication', async () => {\n      const user = await testDataFactory.createUser();\n      \n      // Simulate incoming call that gets routed to realtime processor\n      const callPayload = {\n        eventType: 'Microsoft.Communication.CallConnected',\n        data: {\n          callLegId: 'service-comm-test',\n          from: { phoneNumber: '+7777777777' },\n          to: { phoneNumber: user.phone },\n          callConnectionId: 'service-comm-connection'\n        }\n      };\n      \n      const phoneGatewayResponse = await request(phoneGatewayApp)\n        .post('/webhook/incoming-call')\n        .send(callPayload)\n        .expect(200);\n      \n      expect(phoneGatewayResponse.body.action).toBe('ai_processing');\n      \n      // Verify realtime processor received the call data\n      // This would typically be done through message queues or direct HTTP calls\n      const callRecord = await dbClient.query(\n        'SELECT * FROM call_records WHERE azure_call_id = $1',\n        ['service-comm-test']\n      );\n      \n      expect(callRecord.rows[0].call_type).toBe('spam_suspected');\n      \n      // Test realtime processor health with call context\n      const realtimeResponse = await request(realtimeProcessorApp)\n        .get('/health')\n        .expect(200);\n      \n      expect(realtimeResponse.body).toBeHealthy();\n    });\n    \n    it('should handle user profile updates across services', async () => {\n      const user = await testDataFactory.createUser();\n      \n      // Update user in user management service\n      const updateData = {\n        personality: 'humorous',\n        preferences: {\n          responseStyle: 'witty',\n          callHandling: 'assertive'\n        }\n      };\n      \n      await request(userManagementApp)\n        .put(`/users/${user.id}`)\n        .send(updateData)\n        .expect(200);\n      \n      // Verify other services can access updated profile\n      // This simulates how phone-gateway would fetch user profile\n      const profileResponse = await request(userManagementApp)\n        .get(`/users/${user.id}`)\n        .expect(200);\n      \n      expect(profileResponse.body.user.personality).toBe('humorous');\n      expect(profileResponse.body.user.preferences).toEqual(updateData.preferences);\n    });\n  });\n  \n  describe('Database Transactions and Consistency', () => {\n    it('should handle concurrent whitelist updates', async () => {\n      const user = await testDataFactory.createUser();\n      \n      const concurrentPromises = [];\n      const contactCount = 5;\n      \n      // Create multiple whitelist entries concurrently\n      for (let i = 0; i < contactCount; i++) {\n        const promise = request(userManagementApp)\n          .post('/whitelist')\n          .send({\n            userId: user.id,\n            contactPhone: `+${1000000000 + i}`,\n            contactName: `Contact ${i}`\n          });\n        \n        concurrentPromises.push(promise);\n      }\n      \n      const responses = await Promise.all(concurrentPromises);\n      \n      // All requests should succeed\n      responses.forEach(response => {\n        expect(response.status).toBe(201);\n      });\n      \n      // Verify all entries were created\n      const dbContacts = await dbClient.query(\n        'SELECT * FROM smart_whitelists WHERE user_id = $1',\n        [user.id]\n      );\n      \n      expect(dbContacts.rows).toHaveLength(contactCount);\n    });\n    \n    it('should maintain data consistency during call processing', async () => {\n      const user = await testDataFactory.createUser();\n      \n      const callPayload = {\n        eventType: 'Microsoft.Communication.CallConnected',\n        data: {\n          callLegId: 'consistency-test',\n          from: { phoneNumber: '+6666666666' },\n          to: { phoneNumber: user.phone },\n          callConnectionId: 'consistency-connection'\n        }\n      };\n      \n      // Start call processing\n      const callResponse = await request(phoneGatewayApp)\n        .post('/webhook/incoming-call')\n        .send(callPayload)\n        .expect(200);\n      \n      // Simulate conversation data being added\n      const conversationData = {\n        callId: 'consistency-test',\n        speaker: 'caller',\n        text: 'Hello, I am calling about insurance',\n        intent: 'insurance_sales',\n        confidence: 0.92\n      };\n      \n      // This would typically be handled by the conversation engine\n      await dbClient.query(`\n        INSERT INTO conversations (call_record_id, speaker, message_text, intent_category, confidence_score, timestamp)\n        SELECT id, $2, $3, $4, $5, CURRENT_TIMESTAMP\n        FROM call_records WHERE azure_call_id = $1\n      `, [\n        'consistency-test',\n        conversationData.speaker,\n        conversationData.text,\n        conversationData.intent,\n        conversationData.confidence\n      ]);\n      \n      // Verify call record and conversation are linked correctly\n      const conversationRecord = await dbClient.query(`\n        SELECT c.*, cr.azure_call_id\n        FROM conversations c\n        JOIN call_records cr ON c.call_record_id = cr.id\n        WHERE cr.azure_call_id = $1\n      `, ['consistency-test']);\n      \n      expect(conversationRecord.rows).toHaveLength(1);\n      expect(conversationRecord.rows[0].message_text).toBe(conversationData.text);\n      expect(conversationRecord.rows[0].intent_category).toBe(conversationData.intent);\n    });\n  });\n  \n  describe('Caching and Performance', () => {\n    it('should implement efficient caching for user profiles', async () => {\n      const user = await testDataFactory.createUser();\n      \n      // First request - should hit database\n      const start1 = performance.now();\n      const response1 = await request(userManagementApp)\n        .get(`/users/${user.id}`)\n        .expect(200);\n      const dbTime = performance.now() - start1;\n      \n      // Second request - should hit cache\n      const start2 = performance.now();\n      const response2 = await request(userManagementApp)\n        .get(`/users/${user.id}`)\n        .expect(200);\n      const cacheTime = performance.now() - start2;\n      \n      expect(response1.body.user.id).toBe(response2.body.user.id);\n      expect(cacheTime).toBeLessThan(dbTime * 0.5); // Cache should be significantly faster\n      \n      console.log(`DB time: ${dbTime.toFixed(2)}ms, Cache time: ${cacheTime.toFixed(2)}ms`);\n    });\n    \n    it('should handle cache invalidation correctly', async () => {\n      const user = await testDataFactory.createUser();\n      \n      // Cache the user\n      await request(userManagementApp)\n        .get(`/users/${user.id}`)\n        .expect(200);\n      \n      // Verify cache exists\n      let cachedUser = await redisClient.get(`user:${user.id}`);\n      expect(cachedUser).toBeTruthy();\n      \n      // Update user - should invalidate cache\n      await request(userManagementApp)\n        .put(`/users/${user.id}`)\n        .send({ name: 'Cache Invalidation Test' })\n        .expect(200);\n      \n      // Verify cache was invalidated\n      cachedUser = await redisClient.get(`user:${user.id}`);\n      expect(cachedUser).toBeFalsy();\n    });\n  });\n  \n  describe('Error Handling and Recovery', () => {\n    it('should handle database connection failures gracefully', async () => {\n      // Temporarily close database connection\n      await dbClient.end();\n      \n      const response = await request(userManagementApp)\n        .get('/users/non-existent-id')\n        .expect(500);\n      \n      expect(response.body.error).toContain('database');\n      \n      // Reconnect for other tests\n      dbClient = new PgClient({\n        host: 'localhost',\n        port: 5433,\n        database: 'ai_ninja_test',\n        user: 'test_user',\n        password: 'test_password'\n      });\n      await dbClient.connect();\n    });\n    \n    it('should handle Redis connection failures gracefully', async () => {\n      // Disconnect Redis\n      redisClient.disconnect();\n      \n      const user = await testDataFactory.createUser();\n      \n      // Should still work without cache\n      const response = await request(userManagementApp)\n        .get(`/users/${user.id}`)\n        .expect(200);\n      \n      expect(response.body.user.id).toBe(user.id);\n      \n      // Reconnect Redis\n      redisClient = new Redis({\n        host: 'localhost',\n        port: 6380,\n        db: 1\n      });\n    });\n  });\n});\n"