/**\n * Test Data Factory\n * \n * Generates consistent test data for integration and E2E tests\n * with realistic relationships and data patterns.\n */\n\nimport { Client as PgClient } from 'pg';\nimport Redis from 'ioredis';\nimport { faker } from '@faker-js/faker';\nimport * as crypto from 'crypto';\n\nexport interface TestUser {\n  id: string;\n  phone: string;\n  name: string;\n  personality: string;\n  voice_profile_id?: string;\n  preferences?: any;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface TestCallRecord {\n  id: string;\n  user_id: string;\n  caller_phone: string;\n  call_type: string;\n  call_status: string;\n  start_time: Date;\n  end_time?: Date;\n  duration_seconds?: number;\n  azure_call_id?: string;\n  audio_recording_url?: string;\n  processing_metadata?: any;\n  created_at: Date;\n}\n\nexport interface TestConversation {\n  id: string;\n  call_record_id: string;\n  speaker: 'caller' | 'ai';\n  message_text: string;\n  timestamp: Date;\n  confidence_score?: number;\n  intent_category?: string;\n  emotion?: string;\n  processing_latency?: number;\n  created_at: Date;\n}\n\nexport interface TestWhitelistEntry {\n  id: string;\n  user_id: string;\n  contact_phone: string;\n  contact_name?: string;\n  whitelist_type: 'manual' | 'auto' | 'temporary';\n  confidence_score: number;\n  is_active: boolean;\n  expires_at?: Date;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface TestSpamProfile {\n  id: string;\n  phone_hash: string;\n  spam_category: string;\n  risk_score: number;\n  confidence_level: number;\n  feature_vector?: any;\n  behavioral_patterns?: any;\n  total_reports: number;\n  last_activity: Date;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport class TestDataFactory {\n  private dbClient: PgClient;\n  private redisClient: Redis;\n  \n  // Common test data patterns\n  private readonly personalities = ['polite', 'direct', 'humorous', 'professional'];\n  private readonly spamCategories = ['sales_call', 'loan_offer', 'insurance_sales', 'investment_pitch', 'survey', 'robocall'];\n  private readonly callStatuses = ['active', 'completed', 'transferred', 'failed', 'cancelled'];\n  private readonly callTypes = ['spam_suspected', 'whitelisted', 'unknown', 'emergency'];\n  private readonly emotions = ['neutral', 'frustrated', 'polite', 'aggressive', 'confused', 'satisfied'];\n  \n  constructor(dbClient: PgClient, redisClient: Redis) {\n    this.dbClient = dbClient;\n    this.redisClient = redisClient;\n    \n    // Seed faker for consistent test data\n    faker.seed(12345);\n  }\n  \n  async setupSchema(): Promise<void> {\n    console.log('ðŸ”§ Setting up test database schema...');\n    \n    const schemaSql = `\n      -- Create users table\n      CREATE TABLE IF NOT EXISTS users (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        phone_number VARCHAR(20) UNIQUE NOT NULL,\n        name VARCHAR(100) NOT NULL,\n        personality TEXT DEFAULT 'polite',\n        voice_profile_id VARCHAR(100),\n        preferences JSONB DEFAULT '{}',\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n      \n      -- Create smart_whitelists table\n      CREATE TABLE IF NOT EXISTS smart_whitelists (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n        contact_phone VARCHAR(20) NOT NULL,\n        contact_name VARCHAR(100),\n        whitelist_type VARCHAR(20) DEFAULT 'manual',\n        confidence_score DECIMAL(3,2) DEFAULT 1.0,\n        is_active BOOLEAN DEFAULT true,\n        expires_at TIMESTAMP,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        UNIQUE(user_id, contact_phone)\n      );\n      \n      -- Create call_records table\n      CREATE TABLE IF NOT EXISTS call_records (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n        caller_phone VARCHAR(20) NOT NULL,\n        call_type VARCHAR(20) NOT NULL DEFAULT 'unknown',\n        call_status VARCHAR(20) NOT NULL DEFAULT 'active',\n        start_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        end_time TIMESTAMP,\n        duration_seconds INTEGER,\n        azure_call_id VARCHAR(100),\n        audio_recording_url TEXT,\n        processing_metadata JSONB,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n      \n      -- Create conversations table\n      CREATE TABLE IF NOT EXISTS conversations (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        call_record_id UUID NOT NULL REFERENCES call_records(id) ON DELETE CASCADE,\n        speaker VARCHAR(10) NOT NULL,\n        message_text TEXT NOT NULL,\n        timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        confidence_score DECIMAL(3,2),\n        intent_category VARCHAR(50),\n        emotion VARCHAR(20),\n        processing_latency INTEGER,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n      \n      -- Create spam_profiles table\n      CREATE TABLE IF NOT EXISTS spam_profiles (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        phone_hash VARCHAR(64) UNIQUE NOT NULL,\n        spam_category VARCHAR(50) NOT NULL,\n        risk_score DECIMAL(3,2) NOT NULL DEFAULT 0.5,\n        confidence_level DECIMAL(3,2) NOT NULL DEFAULT 0.5,\n        feature_vector JSONB,\n        behavioral_patterns JSONB,\n        total_reports INTEGER DEFAULT 1,\n        last_activity TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n      \n      -- Create user_spam_interactions table\n      CREATE TABLE IF NOT EXISTS user_spam_interactions (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n        spam_profile_id UUID REFERENCES spam_profiles(id) ON DELETE CASCADE,\n        interaction_count INTEGER DEFAULT 1,\n        last_interaction TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        user_feedback VARCHAR(20),\n        effectiveness_score DECIMAL(3,2),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        UNIQUE(user_id, spam_profile_id)\n      );\n      \n      -- Create indexes for performance\n      CREATE INDEX IF NOT EXISTS idx_users_phone ON users(phone_number);\n      CREATE INDEX IF NOT EXISTS idx_whitelists_user_active ON smart_whitelists(user_id, is_active);\n      CREATE INDEX IF NOT EXISTS idx_call_records_user_time ON call_records(user_id, start_time DESC);\n      CREATE INDEX IF NOT EXISTS idx_conversations_call_time ON conversations(call_record_id, timestamp);\n      CREATE INDEX IF NOT EXISTS idx_spam_profiles_hash ON spam_profiles(phone_hash);\n    `;\n    \n    await this.dbClient.query(schemaSql);\n    console.log('âœ… Test database schema set up');\n  }\n  \n  async createUser(overrides: Partial<TestUser> = {}): Promise<TestUser> {\n    const userData = {\n      phone: overrides.phone || this.generatePhoneNumber(),\n      name: overrides.name || faker.person.fullName(),\n      personality: overrides.personality || faker.helpers.arrayElement(this.personalities),\n      voice_profile_id: overrides.voice_profile_id || `voice-${faker.string.alphanumeric(10)}`,\n      preferences: overrides.preferences || {\n        responseStyle: faker.helpers.arrayElement(['casual', 'formal', 'friendly']),\n        callHandling: faker.helpers.arrayElement(['polite', 'assertive', 'brief']),\n        languages: ['en-US']\n      },\n      ...overrides\n    };\n    \n    const query = `\n      INSERT INTO users (phone_number, name, personality, voice_profile_id, preferences)\n      VALUES ($1, $2, $3, $4, $5)\n      RETURNING *\n    `;\n    \n    const values = [\n      userData.phone,\n      userData.name,\n      userData.personality,\n      userData.voice_profile_id,\n      JSON.stringify(userData.preferences)\n    ];\n    \n    const result = await this.dbClient.query(query, values);\n    const user = result.rows[0];\n    \n    // Cache user in Redis for quick lookup\n    await this.redisClient.setex(\n      `user:${user.id}`,\n      3600, // 1 hour\n      JSON.stringify({\n        id: user.id,\n        phone: user.phone_number,\n        name: user.name,\n        personality: user.personality\n      })\n    );\n    \n    return {\n      id: user.id,\n      phone: user.phone_number,\n      name: user.name,\n      personality: user.personality,\n      voice_profile_id: user.voice_profile_id,\n      preferences: user.preferences,\n      created_at: user.created_at,\n      updated_at: user.updated_at\n    };\n  }\n  \n  async createCallRecord(overrides: Partial<TestCallRecord> = {}): Promise<TestCallRecord> {\n    // If user_id not provided, create a new user\n    let userId = overrides.user_id;\n    if (!userId) {\n      const user = await this.createUser();\n      userId = user.id;\n    }\n    \n    const callData = {\n      user_id: userId,\n      caller_phone: overrides.caller_phone || this.generatePhoneNumber(),\n      call_type: overrides.call_type || faker.helpers.arrayElement(this.callTypes),\n      call_status: overrides.call_status || faker.helpers.arrayElement(this.callStatuses),\n      start_time: overrides.start_time || new Date(),\n      end_time: overrides.end_time,\n      duration_seconds: overrides.duration_seconds || (overrides.call_status === 'completed' ? faker.number.int({ min: 30, max: 300 }) : undefined),\n      azure_call_id: overrides.azure_call_id || `azure-call-${faker.string.alphanumeric(10)}`,\n      audio_recording_url: overrides.audio_recording_url || (overrides.call_status === 'completed' ? `https://storage.azure.com/recordings/${faker.string.uuid()}.wav` : undefined),\n      processing_metadata: overrides.processing_metadata || {\n        processedBy: 'ai-engine-v1',\n        processingTime: faker.number.int({ min: 100, max: 2000 }),\n        confidence: faker.number.float({ min: 0.7, max: 0.99 })\n      },\n      ...overrides\n    };\n    \n    const query = `\n      INSERT INTO call_records (\n        user_id, caller_phone, call_type, call_status, start_time, end_time,\n        duration_seconds, azure_call_id, audio_recording_url, processing_metadata\n      )\n      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n      RETURNING *\n    `;\n    \n    const values = [\n      callData.user_id,\n      callData.caller_phone,\n      callData.call_type,\n      callData.call_status,\n      callData.start_time,\n      callData.end_time,\n      callData.duration_seconds,\n      callData.azure_call_id,\n      callData.audio_recording_url,\n      JSON.stringify(callData.processing_metadata)\n    ];\n    \n    const result = await this.dbClient.query(query, values);\n    const record = result.rows[0];\n    \n    return {\n      id: record.id,\n      user_id: record.user_id,\n      caller_phone: record.caller_phone,\n      call_type: record.call_type,\n      call_status: record.call_status,\n      start_time: record.start_time,\n      end_time: record.end_time,\n      duration_seconds: record.duration_seconds,\n      azure_call_id: record.azure_call_id,\n      audio_recording_url: record.audio_recording_url,\n      processing_metadata: record.processing_metadata,\n      created_at: record.created_at\n    };\n  }\n  \n  async createConversation(overrides: Partial<TestConversation> = {}): Promise<TestConversation> {\n    // If call_record_id not provided, create a new call record\n    let callRecordId = overrides.call_record_id;\n    if (!callRecordId) {\n      const callRecord = await this.createCallRecord();\n      callRecordId = callRecord.id;\n    }\n    \n    const conversationData = {\n      call_record_id: callRecordId,\n      speaker: overrides.speaker || faker.helpers.arrayElement(['caller', 'ai'] as const),\n      message_text: overrides.message_text || this.generateConversationMessage(overrides.speaker),\n      timestamp: overrides.timestamp || new Date(),\n      confidence_score: overrides.confidence_score || faker.number.float({ min: 0.8, max: 0.99 }),\n      intent_category: overrides.intent_category || faker.helpers.arrayElement(this.spamCategories),\n      emotion: overrides.emotion || faker.helpers.arrayElement(this.emotions),\n      processing_latency: overrides.processing_latency || faker.number.int({ min: 100, max: 800 }),\n      ...overrides\n    };\n    \n    const query = `\n      INSERT INTO conversations (\n        call_record_id, speaker, message_text, timestamp, confidence_score,\n        intent_category, emotion, processing_latency\n      )\n      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n      RETURNING *\n    `;\n    \n    const values = [\n      conversationData.call_record_id,\n      conversationData.speaker,\n      conversationData.message_text,\n      conversationData.timestamp,\n      conversationData.confidence_score,\n      conversationData.intent_category,\n      conversationData.emotion,\n      conversationData.processing_latency\n    ];\n    \n    const result = await this.dbClient.query(query, values);\n    const conversation = result.rows[0];\n    \n    return {\n      id: conversation.id,\n      call_record_id: conversation.call_record_id,\n      speaker: conversation.speaker,\n      message_text: conversation.message_text,\n      timestamp: conversation.timestamp,\n      confidence_score: conversation.confidence_score,\n      intent_category: conversation.intent_category,\n      emotion: conversation.emotion,\n      processing_latency: conversation.processing_latency,\n      created_at: conversation.created_at\n    };\n  }\n  \n  async createWhitelistEntry(overrides: Partial<TestWhitelistEntry> = {}): Promise<TestWhitelistEntry> {\n    // If user_id not provided, create a new user\n    let userId = overrides.user_id;\n    if (!userId) {\n      const user = await this.createUser();\n      userId = user.id;\n    }\n    \n    const whitelistData = {\n      user_id: userId,\n      contact_phone: overrides.contact_phone || this.generatePhoneNumber(),\n      contact_name: overrides.contact_name || faker.person.fullName(),\n      whitelist_type: overrides.whitelist_type || faker.helpers.arrayElement(['manual', 'auto', 'temporary'] as const),\n      confidence_score: overrides.confidence_score || faker.number.float({ min: 0.8, max: 1.0 }),\n      is_active: overrides.is_active ?? true,\n      expires_at: overrides.expires_at || (overrides.whitelist_type === 'temporary' ? faker.date.future() : undefined),\n      ...overrides\n    };\n    \n    const query = `\n      INSERT INTO smart_whitelists (\n        user_id, contact_phone, contact_name, whitelist_type,\n        confidence_score, is_active, expires_at\n      )\n      VALUES ($1, $2, $3, $4, $5, $6, $7)\n      RETURNING *\n    `;\n    \n    const values = [\n      whitelistData.user_id,\n      whitelistData.contact_phone,\n      whitelistData.contact_name,\n      whitelistData.whitelist_type,\n      whitelistData.confidence_score,\n      whitelistData.is_active,\n      whitelistData.expires_at\n    ];\n    \n    const result = await this.dbClient.query(query, values);\n    const entry = result.rows[0];\n    \n    // Update Redis cache for whitelist\n    await this.updateWhitelistCache(userId);\n    \n    return {\n      id: entry.id,\n      user_id: entry.user_id,\n      contact_phone: entry.contact_phone,\n      contact_name: entry.contact_name,\n      whitelist_type: entry.whitelist_type,\n      confidence_score: parseFloat(entry.confidence_score),\n      is_active: entry.is_active,\n      expires_at: entry.expires_at,\n      created_at: entry.created_at,\n      updated_at: entry.updated_at\n    };\n  }\n  \n  async createSpamProfile(overrides: Partial<TestSpamProfile> = {}): Promise<TestSpamProfile> {\n    const phone = overrides.phone_hash || this.generatePhoneNumber();\n    const phoneHash = crypto.createHash('sha256').update(phone).digest('hex');\n    \n    const spamData = {\n      phone_hash: phoneHash,\n      spam_category: overrides.spam_category || faker.helpers.arrayElement(this.spamCategories),\n      risk_score: overrides.risk_score || faker.number.float({ min: 0.6, max: 0.95 }),\n      confidence_level: overrides.confidence_level || faker.number.float({ min: 0.7, max: 0.99 }),\n      feature_vector: overrides.feature_vector || {\n        callFrequency: faker.number.float({ min: 0.1, max: 1.0 }),\n        timePatterns: faker.helpers.arrayElements(['morning', 'afternoon', 'evening'], 2),\n        durationPatterns: faker.number.float({ min: 0.2, max: 0.8 }),\n        responsePatterns: faker.number.float({ min: 0.1, max: 0.9 })\n      },\n      behavioral_patterns: overrides.behavioral_patterns || {\n        persistence: faker.number.float({ min: 0.3, max: 0.9 }),\n        scriptedSpeech: faker.number.float({ min: 0.5, max: 0.95 }),\n        backgroundNoise: faker.number.float({ min: 0.1, max: 0.7 }),\n        voiceAnalysis: faker.helpers.arrayElement(['robotic', 'human', 'synthetic'])\n      },\n      total_reports: overrides.total_reports || faker.number.int({ min: 1, max: 50 }),\n      last_activity: overrides.last_activity || faker.date.recent(),\n      ...overrides\n    };\n    \n    const query = `\n      INSERT INTO spam_profiles (\n        phone_hash, spam_category, risk_score, confidence_level,\n        feature_vector, behavioral_patterns, total_reports, last_activity\n      )\n      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n      RETURNING *\n    `;\n    \n    const values = [\n      spamData.phone_hash,\n      spamData.spam_category,\n      spamData.risk_score,\n      spamData.confidence_level,\n      JSON.stringify(spamData.feature_vector),\n      JSON.stringify(spamData.behavioral_patterns),\n      spamData.total_reports,\n      spamData.last_activity\n    ];\n    \n    const result = await this.dbClient.query(query, values);\n    const profile = result.rows[0];\n    \n    // Cache spam profile for quick lookup\n    await this.redisClient.setex(\n      `spam:${spamData.phone_hash}`,\n      7200, // 2 hours\n      JSON.stringify({\n        category: profile.spam_category,\n        riskScore: parseFloat(profile.risk_score),\n        confidence: parseFloat(profile.confidence_level)\n      })\n    );\n    \n    return {\n      id: profile.id,\n      phone_hash: profile.phone_hash,\n      spam_category: profile.spam_category,\n      risk_score: parseFloat(profile.risk_score),\n      confidence_level: parseFloat(profile.confidence_level),\n      feature_vector: profile.feature_vector,\n      behavioral_patterns: profile.behavioral_patterns,\n      total_reports: profile.total_reports,\n      last_activity: profile.last_activity,\n      created_at: profile.created_at,\n      updated_at: profile.updated_at\n    };\n  }\n  \n  // Realistic scenario generators\n  async createRealisticUserScenario(userCount: number = 10): Promise<{\n    users: TestUser[],\n    callRecords: TestCallRecord[],\n    conversations: TestConversation[],\n    whitelistEntries: TestWhitelistEntry[],\n    spamProfiles: TestSpamProfile[]\n  }> {\n    const users: TestUser[] = [];\n    const callRecords: TestCallRecord[] = [];\n    const conversations: TestConversation[] = [];\n    const whitelistEntries: TestWhitelistEntry[] = [];\n    const spamProfiles: TestSpamProfile[] = [];\n    \n    // Create users\n    for (let i = 0; i < userCount; i++) {\n      const user = await this.createUser({\n        name: `Test User ${i + 1}`,\n        phone: `+1555000${String(i).padStart(4, '0')}`\n      });\n      users.push(user);\n      \n      // Create whitelist entries for each user (2-5 entries)\n      const whitelistCount = faker.number.int({ min: 2, max: 5 });\n      for (let j = 0; j < whitelistCount; j++) {\n        const entry = await this.createWhitelistEntry({\n          user_id: user.id,\n          contact_name: `Contact ${j + 1} for ${user.name}`\n        });\n        whitelistEntries.push(entry);\n      }\n      \n      // Create call records for each user (5-20 calls)\n      const callCount = faker.number.int({ min: 5, max: 20 });\n      for (let k = 0; k < callCount; k++) {\n        const isSpam = faker.datatype.boolean(0.7); // 70% spam calls\n        const callRecord = await this.createCallRecord({\n          user_id: user.id,\n          call_type: isSpam ? 'spam_suspected' : faker.helpers.arrayElement(['whitelisted', 'unknown']),\n          call_status: faker.helpers.weightedArrayElement([\n            { weight: 0.6, value: 'completed' },\n            { weight: 0.2, value: 'transferred' },\n            { weight: 0.1, value: 'failed' },\n            { weight: 0.1, value: 'cancelled' }\n          ])\n        });\n        callRecords.push(callRecord);\n        \n        // Create conversations for completed calls\n        if (callRecord.call_status === 'completed') {\n          const conversationCount = faker.number.int({ min: 2, max: 8 });\n          for (let l = 0; l < conversationCount; l++) {\n            const speaker = l % 2 === 0 ? 'caller' : 'ai';\n            const conversation = await this.createConversation({\n              call_record_id: callRecord.id,\n              speaker: speaker as 'caller' | 'ai',\n              timestamp: new Date(callRecord.start_time.getTime() + (l * 10000)) // 10s intervals\n            });\n            conversations.push(conversation);\n          }\n        }\n        \n        // Create spam profiles for spam calls\n        if (isSpam && faker.datatype.boolean(0.8)) {\n          const profile = await this.createSpamProfile();\n          spamProfiles.push(profile);\n        }\n      }\n    }\n    \n    return {\n      users,\n      callRecords,\n      conversations,\n      whitelistEntries,\n      spamProfiles\n    };\n  }\n  \n  // Utility methods\n  private generatePhoneNumber(): string {\n    const areaCode = faker.helpers.arrayElement(['555', '415', '310', '212', '713']);\n    const exchange = faker.string.numeric(3);\n    const number = faker.string.numeric(4);\n    return `+1${areaCode}${exchange}${number}`;\n  }\n  \n  private generateConversationMessage(speaker?: 'caller' | 'ai'): string {\n    if (speaker === 'caller') {\n      return faker.helpers.arrayElement([\n        'Hello, I am calling about a special insurance offer',\n        'Hi there, we have a great loan opportunity for you',\n        'Good morning, I represent an investment company',\n        'This is regarding your recent credit application',\n        'We have an exclusive offer just for you',\n        'I am calling from XYZ Financial Services'\n      ]);\n    } else {\n      return faker.helpers.arrayElement([\n        'Thank you for calling, but I am not interested at this time',\n        'I appreciate the offer, but I already have what I need',\n        'Not interested, please remove my number from your list',\n        'I am not looking for this service right now',\n        'Thanks but no thanks. Have a good day',\n        'I prefer not to discuss this over the phone'\n      ]);\n    }\n  }\n  \n  private async updateWhitelistCache(userId: string): Promise<void> {\n    const whitelistQuery = `\n      SELECT contact_phone, contact_name, confidence_score\n      FROM smart_whitelists\n      WHERE user_id = $1 AND is_active = true\n      AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)\n    `;\n    \n    const result = await this.dbClient.query(whitelistQuery, [userId]);\n    \n    await this.redisClient.setex(\n      `whitelist:${userId}`,\n      3600,\n      JSON.stringify(result.rows)\n    );\n  }\n  \n  // Auth token generation for E2E tests\n  async generateAuthToken(userId: string): Promise<string> {\n    const jwt = require('jsonwebtoken');\n    \n    const payload = {\n      userId,\n      role: 'admin',\n      permissions: ['read:all', 'write:all'],\n      exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24) // 24 hours\n    };\n    \n    const token = jwt.sign(payload, 'test-secret-key');\n    \n    // Cache token in Redis\n    await this.redisClient.setex(\n      `auth:token:${token}`,\n      86400, // 24 hours\n      JSON.stringify({ userId, role: 'admin' })\n    );\n    \n    return token;\n  }\n  \n  // Cleanup methods\n  async clearAll(): Promise<void> {\n    const tables = [\n      'conversations',\n      'call_records', \n      'user_spam_interactions',\n      'smart_whitelists',\n      'spam_profiles',\n      'users'\n    ];\n    \n    for (const table of tables) {\n      await this.dbClient.query(`TRUNCATE TABLE ${table} RESTART IDENTITY CASCADE`);\n    }\n    \n    // Clear Redis cache\n    await this.redisClient.flushdb();\n  }\n  \n  async clearTestData(): Promise<void> {\n    await this.clearAll();\n  }\n  \n  // Batch operations for performance\n  async createUsersBatch(count: number): Promise<TestUser[]> {\n    const users: TestUser[] = [];\n    const batchSize = 50;\n    \n    for (let i = 0; i < count; i += batchSize) {\n      const batch = [];\n      const remaining = Math.min(batchSize, count - i);\n      \n      for (let j = 0; j < remaining; j++) {\n        batch.push(this.createUser({\n          name: `Batch User ${i + j + 1}`,\n          phone: `+1666000${String(i + j).padStart(4, '0')}`\n        }));\n      }\n      \n      const batchResults = await Promise.all(batch);\n      users.push(...batchResults);\n    }\n    \n    return users;\n  }\n}\n"