import { EventEmitter } from 'events';
import { Logger } from '../utils/logger';
import { RedisClient } from '../utils/redis';
import { DatabaseClient } from '../utils/database';
import { NotificationService } from './notificationService';
import { AutoRemediationService } from './autoRemediationService';
import { v4 as uuidv4 } from 'uuid';

export interface Alert {
  id: string;
  alertName: string;
  severity: 'info' | 'warning' | 'critical';
  status: 'firing' | 'resolved' | 'silenced' | 'inhibited';
  service: string;
  instance?: string;
  message: string;
  description: string;
  impact: string;
  action: string;
  runbookUrl?: string;
  dashboardUrl?: string;
  labels: Record<string, string>;
  annotations: Record<string, string>;
  startsAt: Date;
  endsAt?: Date;
  fingerprint: string;
  groupKey: string;
  metadata?: Record<string, any>;
}

export interface AlertGroup {
  groupKey: string;
  alerts: Alert[];
  severity: 'info' | 'warning' | 'critical';
  status: 'firing' | 'resolved';
  count: number;
  createdAt: Date;
  updatedAt: Date;
  suppressedAlerts: number;
  rootCause?: Alert;
}

export interface AlertRule {
  id: string;
  name: string;
  enabled: boolean;
  inhibitionRules: {
    sourceMatchers: Record<string, string>[];
    targetMatchers: Record<string, string>[];
    equal?: string[];
  }[];
  silenceRules: {
    matchers: Record<string, string>[];
    schedule?: {
      start: string; // HH:mm
      end: string;   // HH:mm
      days: number[]; // 0-6, Sunday=0
    };
  }[];
  escalationRules: {
    severity: 'warning' | 'critical';
    timeThreshold: number; // minutes
    escalateTo: 'warning' | 'critical';
  }[];
  autoRemediationRules: {
    matchers: Record<string, string>[];
    actions: string[];
    cooldownMinutes: number;
  }[];
}

export interface EscalationPolicy {
  id: string;
  name: string;
  rules: {
    level: number;
    wait: number; // minutes
    targets: {
      type: 'slack' | 'email' | 'pagerduty' | 'webhook';
      config: Record<string, any>;
    }[];
  }[];
  businessHoursOnly?: boolean;
  weekendsOnly?: boolean;
}

export class IntelligentAlertManager extends EventEmitter {
  private logger: Logger;
  private redis: RedisClient;
  private database: DatabaseClient;
  private notificationService: NotificationService;
  private autoRemediationService: AutoRemediationService;
  
  private activeAlerts: Map<string, Alert> = new Map();
  private alertGroups: Map<string, AlertGroup> = new Map();
  private alertRules: Map<string, AlertRule> = new Map();
  private escalationPolicies: Map<string, EscalationPolicy> = new Map();
  private silenceCache: Map<string, Date> = new Map();
  
  private processInterval: NodeJS.Timeout | null = null;
  private cleanupInterval: NodeJS.Timeout | null = null;
  
  constructor() {
    super();
    this.logger = new Logger('IntelligentAlertManager');
    this.redis = new RedisClient();
    this.database = new DatabaseClient();
    this.notificationService = new NotificationService();
    this.autoRemediationService = new AutoRemediationService();
  }
  
  async initialize(): Promise<void> {
    this.logger.info('Initializing Intelligent Alert Manager');
    
    try {
      // Load alert rules and policies from database
      await this.loadAlertRules();
      await this.loadEscalationPolicies();
      
      // Start processing intervals
      this.startProcessing();
      
      // Set up event listeners
      this.setupEventListeners();
      
      this.logger.info('Intelligent Alert Manager initialized successfully');
      
    } catch (error) {
      this.logger.error('Failed to initialize Intelligent Alert Manager', { error });
      throw error;
    }
  }
  
  private async loadAlertRules(): Promise<void> {
    try {
      const result = await this.database.query(`
        SELECT * FROM alert_rules WHERE enabled = true
      `);
      
      for (const row of result.rows) {
        const rule: AlertRule = {
          id: row.id,
          name: row.name,
          enabled: row.enabled,
          inhibitionRules: JSON.parse(row.inhibition_rules || '[]'),
          silenceRules: JSON.parse(row.silence_rules || '[]'),
          escalationRules: JSON.parse(row.escalation_rules || '[]'),
          autoRemediationRules: JSON.parse(row.auto_remediation_rules || '[]')
        };
        
        this.alertRules.set(rule.id, rule);
      }
      
      this.logger.info('Alert rules loaded', { count: this.alertRules.size });
      
    } catch (error) {\n      this.logger.error('Error loading alert rules', { error });\n    }\n  }\n  \n  private async loadEscalationPolicies(): Promise<void> {\n    try {\n      const result = await this.database.query(`\n        SELECT * FROM escalation_policies WHERE enabled = true\n      `);\n      \n      for (const row of result.rows) {\n        const policy: EscalationPolicy = {\n          id: row.id,\n          name: row.name,\n          rules: JSON.parse(row.rules),\n          businessHoursOnly: row.business_hours_only,\n          weekendsOnly: row.weekends_only\n        };\n        \n        this.escalationPolicies.set(policy.id, policy);\n      }\n      \n      this.logger.info('Escalation policies loaded', { count: this.escalationPolicies.size });\n      \n    } catch (error) {\n      this.logger.error('Error loading escalation policies', { error });\n    }\n  }\n  \n  private startProcessing(): void {\n    // Process alerts every 30 seconds\n    this.processInterval = setInterval(async () => {\n      try {\n        await this.processAlerts();\n      } catch (error) {\n        this.logger.error('Error in alert processing cycle', { error });\n      }\n    }, 30000);\n    \n    // Cleanup old data every 15 minutes\n    this.cleanupInterval = setInterval(async () => {\n      try {\n        await this.cleanupOldData();\n      } catch (error) {\n        this.logger.error('Error in cleanup cycle', { error });\n      }\n    }, 900000);\n  }\n  \n  private setupEventListeners(): void {\n    // Listen for alerts from Prometheus\n    this.on('prometheusAlert', this.handlePrometheusAlert.bind(this));\n    \n    // Listen for custom alerts\n    this.on('customAlert', this.handleCustomAlert.bind(this));\n    \n    // Listen for resolution events\n    this.on('alertResolved', this.handleAlertResolved.bind(this));\n    \n    // Listen for performance issues\n    this.on('performanceIssue', this.handlePerformanceAlert.bind(this));\n  }\n  \n  // ==========================================\n  // Alert Processing\n  // ==========================================\n  \n  async receiveAlert(alertData: any): Promise<void> {\n    try {\n      const alert = await this.createAlertFromData(alertData);\n      \n      // Check if alert should be silenced\n      if (await this.shouldSilenceAlert(alert)) {\n        alert.status = 'silenced';\n        this.logger.debug('Alert silenced', { alertId: alert.id, alertName: alert.alertName });\n        return;\n      }\n      \n      // Check if alert should be inhibited\n      if (await this.shouldInhibitAlert(alert)) {\n        alert.status = 'inhibited';\n        this.logger.debug('Alert inhibited', { alertId: alert.id, alertName: alert.alertName });\n        return;\n      }\n      \n      // Process the alert\n      await this.processNewAlert(alert);\n      \n    } catch (error) {\n      this.logger.error('Error receiving alert', { error, alertData });\n    }\n  }\n  \n  private async createAlertFromData(data: any): Promise<Alert> {\n    const fingerprint = this.generateFingerprint(data);\n    const groupKey = this.generateGroupKey(data);\n    \n    const alert: Alert = {\n      id: uuidv4(),\n      alertName: data.alertname || data.alert || 'Unknown Alert',\n      severity: this.normalizeSeverity(data.severity || data.labels?.severity),\n      status: data.status || 'firing',\n      service: data.service || data.labels?.job || data.labels?.service || 'unknown',\n      instance: data.instance || data.labels?.instance,\n      message: data.summary || data.annotations?.summary || 'Alert fired',\n      description: data.description || data.annotations?.description || '',\n      impact: data.impact || data.annotations?.impact || '',\n      action: data.action || data.annotations?.action || 'Investigate the issue',\n      runbookUrl: data.runbook_url || data.annotations?.runbook_url,\n      dashboardUrl: data.dashboard_url || data.annotations?.dashboard_url,\n      labels: data.labels || {},\n      annotations: data.annotations || {},\n      startsAt: data.startsAt ? new Date(data.startsAt) : new Date(),\n      endsAt: data.endsAt ? new Date(data.endsAt) : undefined,\n      fingerprint,\n      groupKey,\n      metadata: {\n        source: data.source || 'prometheus',\n        generatorURL: data.generatorURL,\n        receivedAt: new Date()\n      }\n    };\n    \n    return alert;\n  }\n  \n  private generateFingerprint(data: any): string {\n    // Create a unique fingerprint based on alert characteristics\n    const key = JSON.stringify({\n      alertname: data.alertname || data.alert,\n      job: data.labels?.job || data.service,\n      instance: data.labels?.instance || data.instance,\n      severity: data.labels?.severity || data.severity\n    });\n    \n    return Buffer.from(key).toString('base64').substring(0, 16);\n  }\n  \n  private generateGroupKey(data: any): string {\n    // Group alerts by service and alert type\n    return `${data.labels?.job || data.service || 'unknown'}_${data.alertname || data.alert || 'unknown'}`;\n  }\n  \n  private normalizeSeverity(severity: string): 'info' | 'warning' | 'critical' {\n    if (!severity) return 'info';\n    \n    const normalizedSeverity = severity.toLowerCase();\n    \n    if (normalizedSeverity.includes('critical') || normalizedSeverity.includes('fatal')) {\n      return 'critical';\n    } else if (normalizedSeverity.includes('warning') || normalizedSeverity.includes('warn')) {\n      return 'warning';\n    } else {\n      return 'info';\n    }\n  }\n  \n  private async shouldSilenceAlert(alert: Alert): Promise<boolean> {\n    // Check cache first\n    const cacheKey = `silence:${alert.fingerprint}`;\n    const cachedSilence = this.silenceCache.get(cacheKey);\n    \n    if (cachedSilence && cachedSilence > new Date()) {\n      return true;\n    }\n    \n    // Check silence rules\n    for (const rule of Array.from(this.alertRules.values())) {\n      for (const silenceRule of rule.silenceRules) {\n        if (this.matchesMatchers(alert, silenceRule.matchers)) {\n          // Check schedule if specified\n          if (silenceRule.schedule) {\n            const now = new Date();\n            const currentHour = now.getHours();\n            const currentMinutes = now.getMinutes();\n            const currentDay = now.getDay();\n            const currentTime = currentHour * 60 + currentMinutes;\n            \n            const [startHour, startMin] = silenceRule.schedule.start.split(':').map(Number);\n            const [endHour, endMin] = silenceRule.schedule.end.split(':').map(Number);\n            const startTime = startHour * 60 + startMin;\n            const endTime = endHour * 60 + endMin;\n            \n            const isInTimeRange = currentTime >= startTime && currentTime <= endTime;\n            const isInDayRange = silenceRule.schedule.days.includes(currentDay);\n            \n            if (isInTimeRange && isInDayRange) {\n              // Cache the silence for 1 hour\n              const silenceUntil = new Date(Date.now() + 3600000);\n              this.silenceCache.set(cacheKey, silenceUntil);\n              return true;\n            }\n          } else {\n            // Silence without schedule - check if manually silenced\n            const silenceCheck = await this.database.query(`\n              SELECT expires_at FROM alert_silences \n              WHERE fingerprint = $1 AND expires_at > NOW()\n            `, [alert.fingerprint]);\n            \n            if (silenceCheck.rows.length > 0) {\n              const expiresAt = new Date(silenceCheck.rows[0].expires_at);\n              this.silenceCache.set(cacheKey, expiresAt);\n              return true;\n            }\n          }\n        }\n      }\n    }\n    \n    return false;\n  }\n  \n  private async shouldInhibitAlert(alert: Alert): Promise<boolean> {\n    // Check inhibition rules\n    for (const rule of Array.from(this.alertRules.values())) {\n      for (const inhibitionRule of rule.inhibitionRules) {\n        // Check if any source alerts are firing\n        const sourceAlerts = Array.from(this.activeAlerts.values()).filter(activeAlert => \n          activeAlert.status === 'firing' && \n          inhibitionRule.sourceMatchers.some(matcher => this.matchesMatchers(activeAlert, matcher))\n        );\n        \n        if (sourceAlerts.length > 0) {\n          // Check if current alert matches target matchers\n          const matchesTarget = inhibitionRule.targetMatchers.some(matcher => \n            this.matchesMatchers(alert, matcher)\n          );\n          \n          if (matchesTarget) {\n            // Additional check for 'equal' labels\n            if (inhibitionRule.equal && inhibitionRule.equal.length > 0) {\n              const sourceAlert = sourceAlerts[0];\n              const labelsMatch = inhibitionRule.equal.every(labelKey => \n                sourceAlert.labels[labelKey] === alert.labels[labelKey]\n              );\n              \n              if (labelsMatch) {\n                this.logger.debug('Alert inhibited by rule', { \n                  alertId: alert.id,\n                  sourceAlert: sourceAlert.id,\n                  rule: rule.name \n                });\n                return true;\n              }\n            } else {\n              this.logger.debug('Alert inhibited by rule', { \n                alertId: alert.id,\n                rule: rule.name \n              });\n              return true;\n            }\n          }\n        }\n      }\n    }\n    \n    return false;\n  }\n  \n  private matchesMatchers(alert: Alert, matchers: Record<string, string>): boolean {\n    for (const [key, value] of Object.entries(matchers)) {\n      const alertValue = alert.labels[key] || alert[key as keyof Alert] as string;\n      \n      if (!alertValue) return false;\n      \n      // Support regex matching\n      if (value.startsWith('~')) {\n        const regex = new RegExp(value.substring(1));\n        if (!regex.test(alertValue)) return false;\n      } else if (alertValue !== value) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n  \n  private async processNewAlert(alert: Alert): Promise<void> {\n    try {\n      // Check if this is an update to an existing alert\n      const existingAlert = Array.from(this.activeAlerts.values())\n        .find(a => a.fingerprint === alert.fingerprint);\n      \n      if (existingAlert) {\n        await this.updateExistingAlert(existingAlert, alert);\n      } else {\n        await this.handleNewAlert(alert);\n      }\n      \n    } catch (error) {\n      this.logger.error('Error processing new alert', { error, alertId: alert.id });\n    }\n  }\n  \n  private async handleNewAlert(alert: Alert): Promise<void> {\n    // Add to active alerts\n    this.activeAlerts.set(alert.id, alert);\n    \n    // Add to alert group\n    await this.addToAlertGroup(alert);\n    \n    // Store in database\n    await this.storeAlert(alert);\n    \n    // Trigger auto-remediation if applicable\n    await this.triggerAutoRemediation(alert);\n    \n    // Send notifications\n    await this.sendNotifications(alert);\n    \n    // Emit event\n    this.emit('newAlert', alert);\n    \n    this.logger.info('New alert processed', {\n      alertId: alert.id,\n      alertName: alert.alertName,\n      severity: alert.severity,\n      service: alert.service\n    });\n  }\n  \n  private async updateExistingAlert(existing: Alert, updated: Alert): Promise<void> {\n    // Update the existing alert\n    existing.status = updated.status;\n    existing.message = updated.message;\n    existing.description = updated.description;\n    existing.annotations = { ...existing.annotations, ...updated.annotations };\n    existing.labels = { ...existing.labels, ...updated.labels };\n    \n    if (updated.endsAt) {\n      existing.endsAt = updated.endsAt;\n    }\n    \n    // Update in database\n    await this.updateAlert(existing);\n    \n    // Emit event\n    this.emit('alertUpdated', existing);\n    \n    this.logger.debug('Alert updated', { alertId: existing.id });\n  }\n  \n  private async addToAlertGroup(alert: Alert): Promise<void> {\n    let group = this.alertGroups.get(alert.groupKey);\n    \n    if (!group) {\n      group = {\n        groupKey: alert.groupKey,\n        alerts: [],\n        severity: alert.severity,\n        status: 'firing',\n        count: 0,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        suppressedAlerts: 0\n      };\n      \n      this.alertGroups.set(alert.groupKey, group);\n    }\n    \n    group.alerts.push(alert);\n    group.count = group.alerts.length;\n    group.updatedAt = new Date();\n    \n    // Update group severity to the highest\n    if (this.getSeverityWeight(alert.severity) > this.getSeverityWeight(group.severity)) {\n      group.severity = alert.severity;\n    }\n    \n    // Determine root cause (usually the first critical alert)\n    if (alert.severity === 'critical' && !group.rootCause) {\n      group.rootCause = alert;\n    }\n  }\n  \n  private getSeverityWeight(severity: string): number {\n    switch (severity) {\n      case 'critical': return 3;\n      case 'warning': return 2;\n      case 'info': return 1;\n      default: return 0;\n    }\n  }\n  \n  // ==========================================\n  // Auto-Remediation\n  // ==========================================\n  \n  private async triggerAutoRemediation(alert: Alert): Promise<void> {\n    try {\n      // Find applicable auto-remediation rules\n      for (const rule of Array.from(this.alertRules.values())) {\n        for (const remediationRule of rule.autoRemediationRules) {\n          if (this.matchesMatchers(alert, remediationRule.matchers[0] || {})) {\n            // Check cooldown period\n            const lastRemediation = await this.getLastRemediationTime(\n              alert.fingerprint, \n              remediationRule.actions.join(',') \n            );\n            \n            const cooldownMs = remediationRule.cooldownMinutes * 60 * 1000;\n            const now = Date.now();\n            \n            if (!lastRemediation || (now - lastRemediation.getTime()) > cooldownMs) {\n              await this.executeAutoRemediation(alert, remediationRule.actions);\n              \n              // Record remediation time\n              await this.recordRemediationTime(alert.fingerprint, remediationRule.actions.join(','));\n            } else {\n              this.logger.debug('Auto-remediation skipped due to cooldown', {\n                alertId: alert.id,\n                cooldownMinutes: remediationRule.cooldownMinutes\n              });\n            }\n          }\n        }\n      }\n      \n    } catch (error) {\n      this.logger.error('Error triggering auto-remediation', { error, alertId: alert.id });\n    }\n  }\n  \n  private async executeAutoRemediation(alert: Alert, actions: string[]): Promise<void> {\n    this.logger.info('Executing auto-remediation', { alertId: alert.id, actions });\n    \n    try {\n      const results = await this.autoRemediationService.executeActions(actions, {\n        alert,\n        context: {\n          service: alert.service,\n          instance: alert.instance,\n          severity: alert.severity\n        }\n      });\n      \n      // Add remediation information to alert\n      alert.annotations['auto_remediation'] = JSON.stringify({\n        actions,\n        results,\n        executedAt: new Date().toISOString()\n      });\n      \n      await this.updateAlert(alert);\n      \n      this.emit('autoRemediationExecuted', {\n        alert,\n        actions,\n        results\n      });\n      \n    } catch (error) {\n      this.logger.error('Auto-remediation failed', { error, alertId: alert.id, actions });\n      \n      alert.annotations['auto_remediation_error'] = JSON.stringify({\n        actions,\n        error: error.message,\n        failedAt: new Date().toISOString()\n      });\n      \n      await this.updateAlert(alert);\n    }\n  }\n  \n  private async getLastRemediationTime(fingerprint: string, actions: string): Promise<Date | null> {\n    try {\n      const result = await this.database.query(`\n        SELECT executed_at FROM auto_remediations \n        WHERE fingerprint = $1 AND actions = $2 \n        ORDER BY executed_at DESC \n        LIMIT 1\n      `, [fingerprint, actions]);\n      \n      return result.rows.length > 0 ? new Date(result.rows[0].executed_at) : null;\n      \n    } catch (error) {\n      this.logger.error('Error getting last remediation time', { error });\n      return null;\n    }\n  }\n  \n  private async recordRemediationTime(fingerprint: string, actions: string): Promise<void> {\n    try {\n      await this.database.query(`\n        INSERT INTO auto_remediations (fingerprint, actions, executed_at)\n        VALUES ($1, $2, $3)\n      `, [fingerprint, actions, new Date()]);\n      \n    } catch (error) {\n      this.logger.error('Error recording remediation time', { error });\n    }\n  }\n  \n  // ==========================================\n  // Notification System\n  // ==========================================\n  \n  private async sendNotifications(alert: Alert): Promise<void> {\n    try {\n      // Determine escalation policy\n      const policy = await this.getEscalationPolicy(alert);\n      \n      if (!policy) {\n        this.logger.debug('No escalation policy found for alert', { alertId: alert.id });\n        return;\n      }\n      \n      // Send immediate notifications for critical alerts\n      if (alert.severity === 'critical') {\n        await this.sendImmediateNotifications(alert, policy);\n      } else {\n        // Schedule notifications according to policy\n        await this.scheduleNotifications(alert, policy);\n      }\n      \n    } catch (error) {\n      this.logger.error('Error sending notifications', { error, alertId: alert.id });\n    }\n  }\n  \n  private async getEscalationPolicy(alert: Alert): Promise<EscalationPolicy | null> {\n    // Simple policy selection based on service or severity\n    const servicePolicyId = alert.labels['escalation_policy'] || \n                           `${alert.service}-policy`;\n    \n    let policy = this.escalationPolicies.get(servicePolicyId);\n    \n    if (!policy) {\n      // Fall back to default policy\n      policy = this.escalationPolicies.get('default-policy');\n    }\n    \n    // Check business hours and weekend restrictions\n    if (policy && !this.isPolicyActiveNow(policy)) {\n      return null;\n    }\n    \n    return policy || null;\n  }\n  \n  private isPolicyActiveNow(policy: EscalationPolicy): boolean {\n    const now = new Date();\n    const hour = now.getHours();\n    const day = now.getDay();\n    const isWeekend = day === 0 || day === 6;\n    const isBusinessHours = hour >= 9 && hour < 17 && !isWeekend;\n    \n    if (policy.businessHoursOnly && !isBusinessHours) {\n      return false;\n    }\n    \n    if (policy.weekendsOnly && !isWeekend) {\n      return false;\n    }\n    \n    return true;\n  }\n  \n  private async sendImmediateNotifications(alert: Alert, policy: EscalationPolicy): Promise<void> {\n    // Send to first level targets immediately\n    const firstLevel = policy.rules.find(rule => rule.level === 1);\n    \n    if (firstLevel) {\n      await Promise.all(firstLevel.targets.map(target => \n        this.notificationService.send({\n          type: target.type,\n          config: target.config,\n          alert,\n          urgency: 'immediate'\n        })\n      ));\n    }\n    \n    // Schedule escalation if needed\n    if (policy.rules.length > 1) {\n      setTimeout(async () => {\n        if (this.activeAlerts.has(alert.id)) {\n          await this.escalateAlert(alert, policy, 2);\n        }\n      }, (firstLevel?.wait || 15) * 60 * 1000);\n    }\n  }\n  \n  private async scheduleNotifications(alert: Alert, policy: EscalationPolicy): Promise<void> {\n    const firstLevel = policy.rules.find(rule => rule.level === 1);\n    \n    if (firstLevel) {\n      setTimeout(async () => {\n        if (this.activeAlerts.has(alert.id)) {\n          await Promise.all(firstLevel.targets.map(target => \n            this.notificationService.send({\n              type: target.type,\n              config: target.config,\n              alert,\n              urgency: 'normal'\n            })\n          ));\n          \n          // Schedule next level\n          if (policy.rules.length > 1) {\n            setTimeout(async () => {\n              if (this.activeAlerts.has(alert.id)) {\n                await this.escalateAlert(alert, policy, 2);\n              }\n            }, firstLevel.wait * 60 * 1000);\n          }\n        }\n      }, 0); // Send immediately for non-critical\n    }\n  }\n  \n  private async escalateAlert(alert: Alert, policy: EscalationPolicy, level: number): Promise<void> {\n    const escalationLevel = policy.rules.find(rule => rule.level === level);\n    \n    if (!escalationLevel) {\n      return; // No more escalation levels\n    }\n    \n    this.logger.warn('Escalating alert', { \n      alertId: alert.id, \n      level, \n      alertName: alert.alertName \n    });\n    \n    // Send escalation notifications\n    await Promise.all(escalationLevel.targets.map(target => \n      this.notificationService.send({\n        type: target.type,\n        config: target.config,\n        alert,\n        urgency: 'escalation',\n        escalationLevel: level\n      })\n    ));\n    \n    // Schedule next escalation if available\n    const nextLevel = policy.rules.find(rule => rule.level === level + 1);\n    if (nextLevel) {\n      setTimeout(async () => {\n        if (this.activeAlerts.has(alert.id)) {\n          await this.escalateAlert(alert, policy, level + 1);\n        }\n      }, escalationLevel.wait * 60 * 1000);\n    }\n    \n    this.emit('alertEscalated', {\n      alert,\n      level,\n      policy: policy.name\n    });\n  }\n  \n  // ==========================================\n  // Alert Lifecycle Management\n  // ==========================================\n  \n  private async processAlerts(): Promise<void> {\n    const now = new Date();\n    const alerts = Array.from(this.activeAlerts.values());\n    \n    for (const alert of alerts) {\n      // Check for alert expiration\n      if (alert.endsAt && now > alert.endsAt) {\n        await this.resolveAlert(alert, 'expired');\n        continue;\n      }\n      \n      // Check for auto-escalation rules\n      await this.checkEscalationRules(alert);\n    }\n    \n    // Process alert groups\n    await this.processAlertGroups();\n  }\n  \n  private async checkEscalationRules(alert: Alert): Promise<void> {\n    const alertAge = Date.now() - alert.startsAt.getTime();\n    const alertAgeMinutes = alertAge / (1000 * 60);\n    \n    for (const rule of Array.from(this.alertRules.values())) {\n      for (const escalationRule of rule.escalationRules) {\n        if (alert.severity === escalationRule.severity && \n            alertAgeMinutes >= escalationRule.timeThreshold) {\n          \n          // Check if already escalated\n          if (!alert.annotations['escalated_at']) {\n            alert.severity = escalationRule.escalateTo;\n            alert.annotations['escalated_at'] = new Date().toISOString();\n            alert.annotations['escalated_from'] = escalationRule.severity;\n            \n            await this.updateAlert(alert);\n            \n            this.logger.warn('Alert auto-escalated', {\n              alertId: alert.id,\n              from: escalationRule.severity,\n              to: escalationRule.escalateTo,\n              ageMinutes: Math.round(alertAgeMinutes)\n            });\n            \n            this.emit('alertAutoEscalated', alert);\n          }\n        }\n      }\n    }\n  }\n  \n  private async processAlertGroups(): Promise<void> {\n    for (const group of Array.from(this.alertGroups.values())) {\n      // Remove resolved alerts from groups\n      group.alerts = group.alerts.filter(alert => \n        this.activeAlerts.has(alert.id)\n      );\n      \n      group.count = group.alerts.length;\n      \n      // Remove empty groups\n      if (group.count === 0) {\n        this.alertGroups.delete(group.groupKey);\n        continue;\n      }\n      \n      // Update group status\n      const hasFireingAlerts = group.alerts.some(alert => alert.status === 'firing');\n      group.status = hasFireingAlerts ? 'firing' : 'resolved';\n      \n      group.updatedAt = new Date();\n    }\n  }\n  \n  async resolveAlert(alert: Alert, reason: string = 'manual'): Promise<void> {\n    alert.status = 'resolved';\n    alert.endsAt = new Date();\n    alert.annotations['resolved_reason'] = reason;\n    \n    // Remove from active alerts\n    this.activeAlerts.delete(alert.id);\n    \n    // Update in database\n    await this.updateAlert(alert);\n    \n    // Send resolution notification\n    await this.sendResolutionNotification(alert);\n    \n    // Emit event\n    this.emit('alertResolved', alert);\n    \n    this.logger.info('Alert resolved', {\n      alertId: alert.id,\n      alertName: alert.alertName,\n      reason,\n      duration: alert.endsAt.getTime() - alert.startsAt.getTime()\n    });\n  }\n  \n  private async sendResolutionNotification(alert: Alert): Promise<void> {\n    try {\n      const policy = await this.getEscalationPolicy(alert);\n      \n      if (policy) {\n        const firstLevel = policy.rules.find(rule => rule.level === 1);\n        if (firstLevel) {\n          await Promise.all(firstLevel.targets.map(target => \n            this.notificationService.send({\n              type: target.type,\n              config: target.config,\n              alert,\n              urgency: 'resolution'\n            })\n          ));\n        }\n      }\n      \n    } catch (error) {\n      this.logger.error('Error sending resolution notification', { error, alertId: alert.id });\n    }\n  }\n  \n  // ==========================================\n  // Data Persistence\n  // ==========================================\n  \n  private async storeAlert(alert: Alert): Promise<void> {\n    try {\n      await this.database.query(`\n        INSERT INTO alerts \n        (id, alert_name, severity, status, service, instance, message, description, \n         impact, action, runbook_url, dashboard_url, labels, annotations, \n         starts_at, ends_at, fingerprint, group_key, metadata)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)\n      `, [\n        alert.id,\n        alert.alertName,\n        alert.severity,\n        alert.status,\n        alert.service,\n        alert.instance,\n        alert.message,\n        alert.description,\n        alert.impact,\n        alert.action,\n        alert.runbookUrl,\n        alert.dashboardUrl,\n        JSON.stringify(alert.labels),\n        JSON.stringify(alert.annotations),\n        alert.startsAt,\n        alert.endsAt,\n        alert.fingerprint,\n        alert.groupKey,\n        JSON.stringify(alert.metadata)\n      ]);\n      \n    } catch (error) {\n      this.logger.error('Error storing alert in database', { error, alertId: alert.id });\n    }\n  }\n  \n  private async updateAlert(alert: Alert): Promise<void> {\n    try {\n      await this.database.query(`\n        UPDATE alerts SET\n          severity = $2,\n          status = $3,\n          message = $4,\n          description = $5,\n          annotations = $6,\n          ends_at = $7,\n          updated_at = $8\n        WHERE id = $1\n      `, [\n        alert.id,\n        alert.severity,\n        alert.status,\n        alert.message,\n        alert.description,\n        JSON.stringify(alert.annotations),\n        alert.endsAt,\n        new Date()\n      ]);\n      \n    } catch (error) {\n      this.logger.error('Error updating alert in database', { error, alertId: alert.id });\n    }\n  }\n  \n  private async cleanupOldData(): Promise<void> {\n    try {\n      // Clean up resolved alerts older than 7 days\n      const result = await this.database.query(`\n        DELETE FROM alerts \n        WHERE status = 'resolved' \n        AND (ends_at < NOW() - INTERVAL '7 days' OR updated_at < NOW() - INTERVAL '7 days')\n      `);\n      \n      if (result.rowCount && result.rowCount > 0) {\n        this.logger.info('Cleaned up old resolved alerts', { deletedCount: result.rowCount });\n      }\n      \n      // Clean up old auto-remediation records\n      await this.database.query(`\n        DELETE FROM auto_remediations \n        WHERE executed_at < NOW() - INTERVAL '30 days'\n      `);\n      \n      // Clear expired silence cache entries\n      const now = new Date();\n      for (const [key, expiry] of this.silenceCache.entries()) {\n        if (expiry < now) {\n          this.silenceCache.delete(key);\n        }\n      }\n      \n    } catch (error) {\n      this.logger.error('Error cleaning up old data', { error });\n    }\n  }\n  \n  // ==========================================\n  // Event Handlers\n  // ==========================================\n  \n  private async handlePrometheusAlert(data: any): Promise<void> {\n    try {\n      if (Array.isArray(data.alerts)) {\n        for (const alertData of data.alerts) {\n          await this.receiveAlert(alertData);\n        }\n      } else {\n        await this.receiveAlert(data);\n      }\n    } catch (error) {\n      this.logger.error('Error handling Prometheus alert', { error, data });\n    }\n  }\n  \n  private async handleCustomAlert(data: any): Promise<void> {\n    try {\n      await this.receiveAlert(data);\n    } catch (error) {\n      this.logger.error('Error handling custom alert', { error, data });\n    }\n  }\n  \n  private async handleAlertResolved(data: any): Promise<void> {\n    try {\n      const alert = this.activeAlerts.get(data.alertId);\n      if (alert) {\n        await this.resolveAlert(alert, 'external');\n      }\n    } catch (error) {\n      this.logger.error('Error handling alert resolution', { error, data });\n    }\n  }\n  \n  private async handlePerformanceAlert(data: any): Promise<void> {\n    try {\n      const alert = {\n        alertname: 'PerformanceIssue',\n        severity: 'warning',\n        service: 'performance-monitor',\n        summary: `Performance issue detected: Score ${data.performanceScore}`,\n        description: `Performance score dropped to ${data.performanceScore}. Bottlenecks: ${data.bottlenecks.map((b: any) => b.span.operationName).join(', ')}`,\n        impact: 'Medium - User experience may be affected',\n        action: 'Investigate performance bottlenecks and optimize slow operations',\n        labels: {\n          traceId: data.traceId,\n          performanceScore: data.performanceScore.toString()\n        }\n      };\n      \n      await this.receiveAlert(alert);\n      \n    } catch (error) {\n      this.logger.error('Error handling performance alert', { error, data });\n    }\n  }\n  \n  // ==========================================\n  // Public API\n  // ==========================================\n  \n  getActiveAlerts(): Alert[] {\n    return Array.from(this.activeAlerts.values());\n  }\n  \n  getAlertGroups(): AlertGroup[] {\n    return Array.from(this.alertGroups.values());\n  }\n  \n  async silenceAlert(fingerprint: string, duration: number): Promise<void> {\n    const expiresAt = new Date(Date.now() + duration);\n    \n    await this.database.query(`\n      INSERT INTO alert_silences (fingerprint, expires_at, created_by)\n      VALUES ($1, $2, $3)\n      ON CONFLICT (fingerprint) DO UPDATE SET\n        expires_at = EXCLUDED.expires_at,\n        updated_at = NOW()\n    `, [fingerprint, expiresAt, 'system']);\n    \n    this.silenceCache.set(`silence:${fingerprint}`, expiresAt);\n    \n    this.logger.info('Alert silenced', { fingerprint, duration });\n  }\n  \n  async unsilenceAlert(fingerprint: string): Promise<void> {\n    await this.database.query(`\n      DELETE FROM alert_silences WHERE fingerprint = $1\n    `, [fingerprint]);\n    \n    this.silenceCache.delete(`silence:${fingerprint}`);\n    \n    this.logger.info('Alert unsilenced', { fingerprint });\n  }\n  \n  async getAlertStatistics(): Promise<{\n    totalActive: number;\n    criticalCount: number;\n    warningCount: number;\n    groupCount: number;\n    avgResolutionTime: number;\n  }> {\n    const activeAlerts = Array.from(this.activeAlerts.values());\n    const totalActive = activeAlerts.length;\n    const criticalCount = activeAlerts.filter(a => a.severity === 'critical').length;\n    const warningCount = activeAlerts.filter(a => a.severity === 'warning').length;\n    const groupCount = this.alertGroups.size;\n    \n    // Calculate average resolution time from database\n    const resolutionResult = await this.database.query(`\n      SELECT AVG(EXTRACT(EPOCH FROM (ends_at - starts_at))) as avg_resolution_seconds\n      FROM alerts \n      WHERE status = 'resolved' \n      AND ends_at >= NOW() - INTERVAL '24 hours'\n    `);\n    \n    const avgResolutionTime = resolutionResult.rows.length > 0 ? \n      Math.round(parseFloat(resolutionResult.rows[0].avg_resolution_seconds) || 0) : 0;\n    \n    return {\n      totalActive,\n      criticalCount,\n      warningCount,\n      groupCount,\n      avgResolutionTime\n    };\n  }\n  \n  async shutdown(): Promise<void> {\n    if (this.processInterval) {\n      clearInterval(this.processInterval);\n      this.processInterval = null;\n    }\n    \n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n    \n    await this.notificationService.shutdown();\n    await this.autoRemediationService.shutdown();\n    await this.redis.disconnect();\n    await this.database.disconnect();\n    \n    this.logger.info('Intelligent Alert Manager shut down successfully');\n  }\n}"